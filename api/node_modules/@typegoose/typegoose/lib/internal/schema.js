"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports._buildSchema = void 0;
const mongoose = require("mongoose");
const logSettings_1 = require("../logSettings");
const typegoose_1 = require("../typegoose");
const constants_1 = require("./constants");
const data_1 = require("./data");
const errors_1 = require("./errors");
const processProp_1 = require("./processProp");
const utils_1 = require("./utils");
/**
 * Internal Schema Builder for Classes
 * This Function should not be used directly outside of typegoose internals, use "buildSchema" from typegoose.ts directly
 * @param cl The Class to build a Model from
 * @param origSch A Schema to clone and extend onto
 * @param opt Overwrite SchemaOptions (Merged with Decorator Options)
 * @param isFinalSchema Set if this Schema is the final (top-level) to build, only when "true" are discriminators, hooks, virtuals, etc applied
 * @param overwriteOptions Overwrite ModelOptions for Name Generation (Not Merged with Decorator)
 * @returns Returns the Build Schema
 * @private
 */
function _buildSchema(cl, origSch, opt, isFinalSchema = true, overwriteOptions) {
    var _a, _b;
    (0, utils_1.assertionIsClass)(cl);
    (0, utils_1.assignGlobalModelOptions)(cl); // to ensure global options are applied to the current class
    // Options sanity check
    opt = (0, utils_1.mergeSchemaOptions)((0, utils_1.isNullOrUndefined)(opt) || typeof opt !== 'object' ? {} : opt, cl);
    /** used, because when trying to resolve an child, the overwriteOptions for that child are not available */
    const className = (0, utils_1.getName)(cl);
    const finalName = (0, utils_1.getName)(cl, overwriteOptions);
    logSettings_1.logger.debug('_buildSchema Called for %s with options:', finalName, opt);
    /** Simplify the usage */
    const Schema = mongoose.Schema;
    const ropt = (_a = Reflect.getMetadata(constants_1.DecoratorKeys.ModelOptions, cl)) !== null && _a !== void 0 ? _a : {};
    const schemaOptions = Object.assign({}, (_b = ropt === null || ropt === void 0 ? void 0 : ropt.schemaOptions) !== null && _b !== void 0 ? _b : {}, opt);
    const decorators = Reflect.getMetadata(constants_1.DecoratorKeys.PropCache, cl.prototype);
    if (!(0, utils_1.isNullOrUndefined)(decorators)) {
        for (const decorator of decorators.values()) {
            (0, processProp_1.processProp)(decorator);
        }
    }
    if (!data_1.schemas.has(className)) {
        data_1.schemas.set(className, {});
    }
    let sch;
    if (!(origSch instanceof Schema)) {
        sch = new Schema(data_1.schemas.get(className), schemaOptions);
    }
    else {
        sch = origSch.clone();
        sch.add(data_1.schemas.get(className));
    }
    sch.loadClass(cl);
    if (isFinalSchema) {
        /** Get Metadata for Nested Discriminators */
        const disMap = Reflect.getMetadata(constants_1.DecoratorKeys.NestedDiscriminators, cl);
        if (disMap instanceof Map) {
            for (const [key, discriminators] of disMap) {
                logSettings_1.logger.debug('Applying Nested Discriminators for:', key, discriminators);
                const path = sch.path(key);
                // TODO: add test for this error
                (0, utils_1.assertion)(!(0, utils_1.isNullOrUndefined)(path), () => new errors_1.PathNotInSchemaError(finalName, key));
                // TODO: add test for this error
                (0, utils_1.assertion)(typeof path.discriminator === 'function', () => new errors_1.NoDiscriminatorFunctionError(finalName, key));
                for (const { type: child, value: childName } of discriminators) {
                    const childSch = (0, utils_1.getName)(child) === finalName ? sch : (0, typegoose_1.buildSchema)(child);
                    const discriminatorKey = childSch.get('discriminatorKey');
                    if (!!discriminatorKey && childSch.path(discriminatorKey)) {
                        // skip this check, otherwise "extends DiscriminatorBase" would not be allowed (discriminators cannot have the discriminator key defined multiple times)
                        childSch.paths[discriminatorKey].options.$skipDiscriminatorCheck = true;
                    }
                    path.discriminator((0, utils_1.getName)(child), childSch, childName);
                }
            }
        }
        // Hooks
        {
            /** Get Metadata for PreHooks */
            const preHooks = Reflect.getMetadata(constants_1.DecoratorKeys.HooksPre, cl);
            if (Array.isArray(preHooks)) {
                // "as any" is used here because mongoose now has static typings for method names, but the intermediate "IHooksArray" has "string"
                preHooks.forEach((obj) => sch.pre(obj.method, obj.options, obj.func));
            }
            /** Get Metadata for PreHooks */
            const postHooks = Reflect.getMetadata(constants_1.DecoratorKeys.HooksPost, cl);
            if (Array.isArray(postHooks)) {
                // "as any" is used here because mongoose now has static typings for method names, but the intermediate "IHooksArray" has "string"
                postHooks.forEach((obj) => sch.post(obj.method, obj.options, obj.func));
            }
        }
        /** Get Metadata for Virtual Populates */
        const virtuals = Reflect.getMetadata(constants_1.DecoratorKeys.VirtualPopulate, cl);
        if (virtuals instanceof Map) {
            for (const [key, options] of virtuals) {
                logSettings_1.logger.debug('Applying Virtual Populates:', key, options);
                sch.virtual(key, options);
            }
        }
        /** Get Metadata for indices */
        const indices = Reflect.getMetadata(constants_1.DecoratorKeys.Index, cl);
        if (Array.isArray(indices)) {
            for (const index of indices) {
                logSettings_1.logger.debug('Applying Index:', index);
                sch.index(index.fields, index.options);
            }
        }
        /** Get Metadata for Query Methods */
        const queryMethods = Reflect.getMetadata(constants_1.DecoratorKeys.QueryMethod, cl);
        if (queryMethods instanceof Map) {
            for (const [funcName, func] of queryMethods) {
                logSettings_1.logger.debug('Applying Query Method:', funcName, func);
                sch.query[funcName] = func;
            }
        }
        /** Get Metadata for indices */
        const plugins = Reflect.getMetadata(constants_1.DecoratorKeys.Plugins, cl);
        if (Array.isArray(plugins)) {
            for (const plugin of plugins) {
                logSettings_1.logger.debug('Applying Plugin:', plugin);
                sch.plugin(plugin.mongoosePlugin, plugin.options);
            }
        }
        // this method is to get the typegoose name of the model/class if it is user-handled (like buildSchema, then manually mongoose.model)
        sch.method('typegooseName', () => {
            return finalName;
        });
    }
    // add the class to the constructors map
    data_1.constructors.set(finalName, cl);
    return sch;
}
exports._buildSchema = _buildSchema;
//# sourceMappingURL=data:application/json;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoic2NoZW1hLmpzIiwic291cmNlUm9vdCI6IiIsInNvdXJjZXMiOlsiLi4vLi4vc3JjL2ludGVybmFsL3NjaGVtYS50cyJdLCJuYW1lcyI6W10sIm1hcHBpbmdzIjoiOzs7QUFBQSxxQ0FBcUM7QUFDckMsZ0RBQXdDO0FBQ3hDLDRDQUEyQztBQVkzQywyQ0FBNEM7QUFDNUMsaUNBQStDO0FBQy9DLHFDQUE4RTtBQUM5RSwrQ0FBNEM7QUFDNUMsbUNBQWdJO0FBRWhJOzs7Ozs7Ozs7O0dBVUc7QUFDSCxTQUFnQixZQUFZLENBQzFCLEVBQUssRUFDTCxPQUE4QixFQUM5QixHQUE0QixFQUM1QixnQkFBeUIsSUFBSSxFQUM3QixnQkFBZ0M7O0lBRWhDLElBQUEsd0JBQWdCLEVBQUMsRUFBRSxDQUFDLENBQUM7SUFFckIsSUFBQSxnQ0FBd0IsRUFBQyxFQUFFLENBQUMsQ0FBQyxDQUFDLDREQUE0RDtJQUUxRix1QkFBdUI7SUFDdkIsR0FBRyxHQUFHLElBQUEsMEJBQWtCLEVBQUMsSUFBQSx5QkFBaUIsRUFBQyxHQUFHLENBQUMsSUFBSSxPQUFPLEdBQUcsS0FBSyxRQUFRLENBQUMsQ0FBQyxDQUFDLEVBQUUsQ0FBQyxDQUFDLENBQUMsR0FBRyxFQUFFLEVBQUUsQ0FBQyxDQUFDO0lBRTNGLDJHQUEyRztJQUMzRyxNQUFNLFNBQVMsR0FBRyxJQUFBLGVBQU8sRUFBQyxFQUFFLENBQUMsQ0FBQztJQUM5QixNQUFNLFNBQVMsR0FBRyxJQUFBLGVBQU8sRUFBQyxFQUFFLEVBQUUsZ0JBQWdCLENBQUMsQ0FBQztJQUVoRCxvQkFBTSxDQUFDLEtBQUssQ0FBQywwQ0FBMEMsRUFBRSxTQUFTLEVBQUUsR0FBRyxDQUFDLENBQUM7SUFFekUseUJBQXlCO0lBQ3pCLE1BQU0sTUFBTSxHQUFHLFFBQVEsQ0FBQyxNQUFNLENBQUM7SUFDL0IsTUFBTSxJQUFJLEdBQWtCLE1BQUEsT0FBTyxDQUFDLFdBQVcsQ0FBQyx5QkFBYSxDQUFDLFlBQVksRUFBRSxFQUFFLENBQUMsbUNBQUksRUFB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